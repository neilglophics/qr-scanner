import { app, BrowserWindow, ipcMain } from 'electron';
import { getPrinters, print, getDefaultPrinter } from 'pdf-to-printer';
import * as path from 'path';
import * as fs from 'fs';
import axios, { AxiosResponse } from 'axios';
import { QR } from './models/qr';
import { PrintOption } from './constants/print-option';
import { Printer } from './models/printer';
import invoiceMapper from './utils/invoice-mapper';
import * as dotenv from 'dotenv';
import { accountMapper, Environment } from './utils/account-mapper';
import { exec } from 'child_process';
import { stdout } from 'process';
import { promisify } from 'util';
dotenv.config();

const promisifyExec = promisify(exec);
const platform = process.platform;
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let cachedDefaultPrinter: string | null = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 1080,
    width: 1920,
    autoHideMenuBar: true,
    // resizable: false,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  /* 
   * Override the default Content Security Policy (CSP) to allow the use of blob URLs.
   * This is required for QR code scanning libraries like ZXing that generate blob-based image or video sources.
   */
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self'; " +
          "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
          "style-src 'self' 'unsafe-inline'; " +
          "img-src * blob: data:;"
        ]
      }
    });
  });

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();
};

app.whenReady().then(() => {
  createWindow()

  ipcMain.handle('get-printers', async () => {
    switch (platform) {
      case 'win32':
        return await getPrinters();
      case 'linux':
        const { stdout } = await promisifyExec('lpstat -p');
        return stdout.split('\n')
          .filter(line => line.startsWith('printer '))
          .map(line => ({ name: line.split(' ')[1] }));
      default:
        return {
          status: 'ERROR',
          error: 'OS not supported!'
        }
    }
  });

  /*
    * Downloads a PDF file from the provided URL and saves it as a temporary file.
    * Once downloaded, the PDF is used for printing.
    * After the print attempt (successful or failed), the temporary file is automatically deleted to free up disk space.
  */
  ipcMain.handle('print', async (_event: Electron.IpcMainInvokeEvent, data: QR, printerName: string | null, printOption: PrintOption, manualLookup: boolean = false) => {
    let apiUrl = manualLookup ? manualSearch(data.invoice_no) : data.url
    if (!apiUrl) {
      return {
        status: 'ERROR',
        error: 'Invalid Invoice Number.',
      };
    }

    const tempFileName = `downloaded_${Date.now()}.pdf`;
    const localFilePath = path.join(app.getPath('temp'), tempFileName);
    let fileResponse: AxiosResponse<any, any>

    if (!cachedDefaultPrinter) {
      const defPrinterRes = await getDefPrinter();
      if (defPrinterRes.status === 'SUCCESS') {
        cachedDefaultPrinter = defPrinterRes.printer;
      } else {
        return defPrinterRes
      }
    }
    const printer = printerName ? printerName : cachedDefaultPrinter;
    if (printOption === PrintOption.WAYBILL) {
      try {
        // Get Waybill URL from api
        const response = await axios({
          method: 'GET',
          url: `${apiUrl}/index.php/api/qr-scanner/get-waybill-url/${data.invoice_no}`,
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest',
            'Request-From': 'admin-panel',
            // Custom header to bypass Laravel Cors setup
            'X-App-Source': 'electron-app'
          },
        });

        // Download Waybill PDF
        fileResponse = await axios.get(response.data.data, { responseType: 'stream' });
      } catch (error) {
        console.log('API error response:', error?.response?.data);
        return {
          status: 'ERROR',
          error: error?.response?.data.error ?? 'Error',
        };
      }

    } else {
      try {
        const response = await axios({
          method: 'GET',
          url: `${apiUrl}/index.php/pdf/job-details/preview?invoice_no=${data.invoice_no}&order_master_id=${data.id}&email=${data.email}`,
          responseType: 'stream'
        });
        fileResponse = response;
      } catch (error) {
        console.log(error)
        return {
          status: 'ERROR',
          error: 'Error in fething pdf',
        };
      }
    }

    await new Promise<void>((resolve, reject) => {
      const writer = fs.createWriteStream(localFilePath);
      fileResponse.data.pipe(writer);
      writer.on('finish', resolve);
      writer.on('error', reject);
    });

    try {
      const filePrinted = await printFile(localFilePath, printer);
      if (!filePrinted) {
        return {
          status: 'ERROR',
          error: `OS not supported!`,
        };
      }
      return {
        status: 'SUCCESS',
        message: `PDF downloaded and printed successfully. Path: ${localFilePath}`
      };
    } catch (error) {
      return {
        status: 'ERROR',
        error: `Printing failed: ${error}`,
      };
    } finally {
      // Clear the temp file
      fs.unlink(localFilePath, (unlinkErr) => {
        if (unlinkErr) {
          console.error('[CLEANUP] Failed to delete temp file:', unlinkErr);
        } else {
          console.log('[CLEANUP] Temp file deleted:', localFilePath);
        }
      });
    }
  })
})

ipcMain.handle('getItems', async (_event: Electron.IpcMainInvokeEvent, data: QR, manualLookup: boolean = false) => {

  let apiUrl = manualLookup ? manualSearch(data.invoice_no) : data.url
  if (!apiUrl) {
    return {
      status: 'FAIL',
      error: 'Invalid Invoice Number.',
    };
  }
  try {
    const response = await axios({
      method: 'GET',
      url: `${apiUrl}/index.php/api/qr-scanner/get-items/${data.invoice_no}`,
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
        // Custom header to bypass Laravel Cors setup
        'X-App-Source': 'electron-app'
      },
    });

    if (response.data.status === 'SUCCESS') {
      return {
        status: response.data.status,
        response: response.data,
      };
    } else {
      return {
        status: response.data.status,
        error: response.data.message,
      };
    }
  } catch (error) {
    return {
      status: 'FAIL',
      error: error?.message ?? 'Error',
    };
  }
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});


function manualSearch(invoiceNo: string): string {
  const account = invoiceMapper(invoiceNo);
  if (!account) {
    console.warn(`No account found for invoice number: ${invoiceNo}`);
    return null;
  }
  const env = process.env.APP_ENV as Environment;

  if (!env) {
    console.warn('Environment variable APP_ENV is not set.');
    return null;
  }
  return accountMapper(account, env);
}


/**
 * Retrieves the system's default printer name based on the operating system.
 *
 * - Windows: Uses `getDefaultPrinter()` from `pdf-to-printer`.
 * - Linux:
 *    - Verifies that the CUPS service is installed and running.
 *    - Uses `lpstat -d` to get the system's default printer.
 *
 * @returns {Promise<{ status: "SUCCESS", printer: string } | { status: "ERROR", error: string }>}
 *          An object indicating success and the default printer name, or an error message.
 */
async function getDefPrinter(): Promise<{ status: "SUCCESS"; printer: string; } | { status: "ERROR"; error: string; }> {
  switch (platform) {
    case 'win32':
      try {
        const printer = await getDefaultPrinter();
        if (getDefaultPrinter) {
          return {
            status: "SUCCESS",
            printer: printer.name
          };
        }
      } catch (error) {
        return {
          status: 'ERROR',
          error: 'No default printer detected!'
        }
      }
      break;
    case 'linux':
      const { stdout } = await promisifyExec('lpstat -p');
      const printers = stdout.split('\n')
        .filter(line => line.startsWith('printer '))
        .map(line => line.split(' ')[1])
      try {
        await promisifyExec('systemctl is-active --quiet cups');
      } catch (error) {
        return {
          status: "ERROR",
          error: `CUPS is not installed or not running. Please install and start the CUPS service`,
        }
      }

      try {
        const { stdout } = await promisifyExec('lpstat -d');
        const match = stdout.match(/^system default destination:\s+(.+)$/m);

        if (match && match[1]) {
          return {
            status: "SUCCESS",
            printer: match[1].trim(),
          }
        } else {
          return {
            status: "ERROR",
            error: "No default printer detected."
          }
        }
      } catch (error) {
        return {
          status: "ERROR",
          error: error?.message,
        };
      }
    default:
      return {
        status: "ERROR",
        error: "OS not supported!",
      };
      break;
  }
}

/**
 * Prints a file to the system's default or specified printer,
 * with support for both Windows and Linux platforms.
 *
 * - On Windows: uses print command from pdf-to-printer command
 * - On Linux: Uses the `lpr` command with optional grayscale (`ColorModel=Gray`) setting.
 * - Other platforms: Returns false (unsupported).
 *
 * @param {string} localFilePath - The full path to the file (usually PDF) to be printed.
 * @returns {Promise<boolean>} - Resolves to `true` if the print command was successfully issued, otherwise `false`.
 */
async function printFile(localFilePath: string, printer: string): Promise<boolean> {
  console.log(printer)
  switch (platform) {
    case 'win32':
      // await print(localFilePath, { printer });
      return true;
    case 'linux':
      const cmd = `lpr -P ${printer} -o ColorModel=Gray "${localFilePath}"`;
      await promisifyExec(cmd);
      return true;
    default:
      return false
  }
}