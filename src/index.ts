import { app, BrowserWindow, ipcMain } from 'electron';
import { print } from 'pdf-to-printer';
import * as path from 'path';
import * as fs from 'fs';
import axios, { AxiosResponse } from 'axios';
import { QR } from './models/qr';
import { PrintOption } from './constants/print-option';
import invoiceMapper from './utils/invoice-mapper';
import * as dotenv from 'dotenv';
import { accountMapper, Environment } from './utils/account-mapper';
import { exec } from 'child_process';
import { promisify } from 'util';
import log from 'electron-log';
import { doneInvoice, getWaybillItems, getWaybillUrl } from './services/waybill';
import { getJobDetails } from './services/job-description';
import ElectronStore from 'electron-store';
import { StoreSchema } from './models/store-schema';

log.info('App is starting...');
dotenv.config();

const promisifyExec = promisify(exec);
const platform = process.platform;
const store = new ElectronStore<StoreSchema>();

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let cachedDefaultPrinter: string | null = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 1080,
    width: 1920,
    autoHideMenuBar: true,
    // resizable: false,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  /* 
   * Override the default Content Security Policy (CSP) to allow the use of blob URLs.
   * This is required for QR code scanning libraries like ZXing that generate blob-based image or video sources.
   */
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self'; " +
          "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
          "style-src 'self' 'unsafe-inline'; " +
          "img-src * blob: data:;"
        ]
      }
    });
  });

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();
};

app.whenReady().then(() => {
  createWindow()

  ipcMain.handle('get-printers', async (event: Electron.IpcMainInvokeEvent) => {
    switch (platform) {
      case 'win32':
        try {
          const printers = await event.sender.getPrintersAsync();
          return printers.map(p => ({
            deviceId: p.name,
            name: p.displayName || p.name,
          }));
        } catch (error) {
          log.error('[Get-Printers] Failed to get printers via Electron:', error);
          return [];
        }

      case 'linux':
        const { stdout } = await promisifyExec('lpstat -p');
        return stdout.split('\n')
          .filter(line => line.startsWith('printer '))
          .map(line => ({ name: line.split(' ')[1] }));
      default:
        return {
          status: 'ERROR',
          error: 'OS not supported!'
        }
    }
  });

  /*
    * Downloads a PDF file from the provided URL and saves it as a temporary file.
    * Once downloaded, the PDF is used for printing.
    * After the print attempt (successful or failed), the temporary file is automatically deleted to free up disk space.
  */
  ipcMain.handle('print', async (_event: Electron.IpcMainInvokeEvent, data: QR, printerName: string | null, printOption: PrintOption, manualLookup: boolean = false) => {
    let apiUrl = manualLookup ? manualSearch(data.invoice_no) : data.url
    if (!apiUrl) {
      return {
        status: 'ERROR',
        error: 'Invalid Invoice Number.',
      };
    }

    const tempFileName = `downloaded_${Date.now()}.pdf`;
    const localFilePath = path.join(app.getPath('temp'), tempFileName);
    let fileResponse: AxiosResponse<any, any>

    if (!cachedDefaultPrinter) {
      const defPrinterRes = await getDefPrinter();
      if (defPrinterRes.status === 'SUCCESS') {
        cachedDefaultPrinter = defPrinterRes.printer;
      } else {
        return defPrinterRes
      }
    }

    const printer = printerName ? printerName : cachedDefaultPrinter;
    if (printOption === PrintOption.WAYBILL) {
      try {
        // Get Waybill URL from api
        const response = await getWaybillUrl(apiUrl, data.invoice_no);

        // Download Waybill PDF
        fileResponse = await axios.get(response.data.data, { responseType: 'stream' });
      } catch (error) {
        log.error('[Waybill Url] API error response:', error?.response?.data);
        return {
          status: 'ERROR',
          error: error?.response?.data.error ?? 'Error',
        };
      }

    } else {
      try {
        const response = await getJobDetails(apiUrl, data);
        fileResponse = response;
      } catch (error) {
        log.error('[Job Description] API error response:', error?.response?.data)
        return {
          status: 'ERROR',
          error: 'Error in fething pdf',
        };
      }
    }

    await new Promise<void>((resolve, reject) => {
      const writer = fs.createWriteStream(localFilePath);
      fileResponse.data.pipe(writer);
      writer.on('finish', resolve);
      writer.on('error', reject);
    });

    try {
      const filePrinted = await printFile(localFilePath, printer);
      if (!filePrinted) {
        return {
          status: 'ERROR',
          error: `OS not supported!`,
        };
      }

      try {
        const response = await doneInvoice(apiUrl, data.invoice_no);
        log.info('[Done Invoice] Invoice status changed', response.data);
      } catch (error) {
        log.error('[Done Invoice] Unable to process invoice', error);
      }

      return {
        status: 'SUCCESS',
        message: `PDF downloaded and printed successfully. Path: ${localFilePath}`
      };
    } catch (error) {
      return {
        status: 'ERROR',
        error: `Printing failed: ${error}`,
      };
    } finally {
      // Clear the temp file
      fs.unlink(localFilePath, (unlinkErr) => {
        if (unlinkErr) {
          log.error('[CLEANUP] Failed to delete temp file:', unlinkErr);
        } else {
          log.info('[CLEANUP] Temp file deleted:', localFilePath);
        }
      });
    }
  })
})

ipcMain.handle('getItems', async (_event: Electron.IpcMainInvokeEvent, data: QR, manualLookup: boolean = false) => {

  let apiUrl = manualLookup ? manualSearch(data.invoice_no) : data.url
  if (!apiUrl) {
    return {
      status: 'FAIL',
      error: 'Invalid Invoice Number.',
    };
  }
  try {
    const response = await getWaybillItems(apiUrl, data.invoice_no);

    if (response.data.status === 'SUCCESS') {
      return {
        status: response.data.status,
        response: response.data,
      };
    } else {
      return {
        status: response.data.status,
        error: response.data.message,
      };
    }
  } catch (error) {
    log.error('[Get Items] Failed to fetched items:', error);
    return {
      status: 'FAIL',
      error: error?.message ?? 'Error',
    };
  }
})

ipcMain.handle('setPrinter', (_event: Electron.IpcMainInvokeEvent, printerName: string) => {
  store.set('selectedPrinter', printerName);
})

ipcMain.handle('getConfigDefaultPrinter', (_event: Electron.IpcMainInvokeEvent) => {
  const configDeaultPrinter = store.get('selectedPrinter');
  log.info('[Default Printer]', configDeaultPrinter);
  if (configDeaultPrinter) {
    return {
      deviceId: configDeaultPrinter,
      name: configDeaultPrinter
    }
  } else {
    return null;
  }
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});


function manualSearch(invoiceNo: string): string {
  const account = invoiceMapper(invoiceNo);
  if (!account) {
    console.warn(`No account found for invoice number: ${invoiceNo}`);
    return null;
  }
  const env = process.env.APP_ENV as Environment;

  if (!env) {
    console.warn('Environment variable APP_ENV is not set.');
    return null;
  }
  return accountMapper(account, env);
}


/**
 * Retrieves the system's default printer name based on the operating system.
 *
 * - Windows: Uses `getDefaultPrinter()` from `pdf-to-printer`.
 * - Linux:
 *    - Verifies that the CUPS service is installed and running.
 *    - Uses `lpstat -d` to get the system's default printer.
 *
 * @returns {Promise<{ status: "SUCCESS", printer: string } | { status: "ERROR", error: string }>}
 *          An object indicating success and the default printer name, or an error message.
 */
async function getDefPrinter(): Promise<{ status: "SUCCESS"; printer: string; } | { status: "ERROR"; error: string; }> {
  switch (platform) {
    case 'win32':
      const configDeaultPrinter = store.get('selectedPrinter');
      if (configDeaultPrinter) {
        return {
          status: "SUCCESS",
          printer: configDeaultPrinter
        };
      } else {
        try {
          const { stdout } = await promisifyExec(
            'powershell -Command "Get-CimInstance -ClassName Win32_Printer | Where-Object { $_.Default -eq $true } | Select-Object -ExpandProperty Name"'
          );
          const printer = stdout.trim();
          if (printer) {
            return {
              status: 'SUCCESS',
              printer
            };
          } else {
            return {
              status: 'ERROR',
              error: 'No default printer detected.'
            };
          }
        } catch (error) {
          log.warn(`[Get Default Printer Windows] Failed: ${error}`)
          return {
            status: 'ERROR',
            error: `PowerShell failed: ${error.message}`
          };
        }
      }

    case 'linux':
      const { stdout } = await promisifyExec('lpstat -p');
      const printers = stdout.split('\n')
        .filter(line => line.startsWith('printer '))
        .map(line => line.split(' ')[1])
      try {
        await promisifyExec('systemctl is-active --quiet cups');
      } catch (error) {
        return {
          status: "ERROR",
          error: `CUPS is not installed or not running. Please install and start the CUPS service`,
        }
      }

      try {
        const { stdout } = await promisifyExec('lpstat -d');
        const match = stdout.match(/^system default destination:\s+(.+)$/m);

        if (match && match[1]) {
          return {
            status: "SUCCESS",
            printer: match[1].trim(),
          }
        } else {
          return {
            status: "ERROR",
            error: "No default printer detected."
          }
        }
      } catch (error) {
        log.warn(`[Get Default Printer Linux] Failed: ${error}`)
        return {
          status: "ERROR",
          error: error?.message,
        };
      }
    default:
      return {
        status: "ERROR",
        error: "OS not supported!",
      };
  }
}

/**
 * Prints a file to the system's default or specified printer,
 * with support for both Windows and Linux platforms.
 *
 * - On Windows: uses print command from pdf-to-printer command
 * - On Linux: Uses the `lpr` command with optional grayscale (`ColorModel=Gray`) setting.
 * - Other platforms: Returns false (unsupported).
 *
 * @param {string} localFilePath - The full path to the file (usually PDF) to be printed.
 * @returns {Promise<boolean>} - Resolves to `true` if the print command was successfully issued, otherwise `false`.
 */
async function printFile(localFilePath: string, printer: string): Promise<boolean> {
  switch (platform) {
    case 'win32':
      try {
        await print(localFilePath, { printer });
        log.info('Printed successfully on printer', printer);
        return true;
      } catch (err) {
        log.error('Print failed:', err);
      }
    case 'linux':
      const cmd = `lpr -P ${printer} -o ColorModel=Gray "${localFilePath}"`;
      await promisifyExec(cmd);
      return true;
    default:
      return false
  }
}